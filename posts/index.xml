<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on This is Alex Zhang</title>
    <link>https://tokers.github.io/posts/</link>
    <description>Recent content in Posts on This is Alex Zhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Aug 2018 15:47:45 +0800</lastBuildDate>
    
        <atom:link href="https://tokers.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ngx_lua 问题归档（1）</title>
      <link>https://tokers.github.io/posts/ngx-lua-drawback-record-1/</link>
      <pubDate>Sun, 05 Aug 2018 15:47:45 +0800</pubDate>
      
      <guid>https://tokers.github.io/posts/ngx-lua-drawback-record-1/</guid>
      <description>&lt;p&gt;前段时间在公司引流机器上偶然发现我们的 OpenResty/Nginx 服务存在进程崩溃的情况，错误日志里记录了如下的堆栈：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngx_http_lua_ssl_cert_handler
tls_post_process_client_hello+0x1be)
ossl_statem_server_post_process_message
read_state_machine
state_machine
ossl_statem_accept
ssl3_read_bytes
ssl3_read_internal
ssl3_read
ssl_read_internal
SSL_read
ngx_ssl_recv
ngx_http_v2_read_handler
ngx_http_v2_idle_handler
ngx_epoll_process_events
ngx_process_events_and_timers
ngx_worker_process_cycle
ngx_spawn_process
ngx_start_worker_processes
ngx_master_process_cycle
main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（在崩溃时打印其堆栈的功能是我们自己加入到 Nginx 中的，官方版本并不支持。）&lt;/p&gt;

&lt;p&gt;从堆栈信息来看，当前正在处理的连接，HTTP 协议已经升级到了  HTTP/2 （&lt;code&gt;ngx_http_v2_idle_handler&lt;/code&gt;）。而从偏顶部的函数来看，当前连接似乎又进入到了 SSL/TLS 握手协议的处理，既然堆栈上出现了 HTTP/2 相关的函数，说明当前一定不是第一次 SSL/TLS 握手（否则 HTTP 协议不可能为 HTTP/2），这让我联想到 &lt;a href=&#34;https://devcentral.f5.com/articles/ssl-profiles-part-6-ssl-renegotiation&#34;&gt;SSL renegotation&lt;/a&gt;，由于没有 coredump 文件的支持，从堆栈信息里看出来的仅限于这么多。&lt;/p&gt;

&lt;p&gt;问题至此，便只能带着问题去看源码了。既然问题还和 HTTP/2 有关，那么我猜测问题可能出现在某些地方没有兼容好 HTTP/2 相关逻辑有关，经过查看 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 函数（这是实现 &lt;code&gt;ssl_certificate_by_lua&lt;/code&gt; 功能的基础函数）和 HTTP/2 相关的逻辑，我发现问题出在 &lt;code&gt;c-&amp;gt;data&lt;/code&gt; 这个成员上，在协议升级到 HTTP/2 后，函数 &lt;code&gt;ngx_htp_v2_init&lt;/code&gt;会被调用到，这个函数将 &lt;code&gt;c-&amp;gt;data&lt;/code&gt; 赋值为了 &lt;code&gt;ngx_http_v2_connection_t&lt;/code&gt; 的一个实例，而在通常（非 HTTP/2） 的处理下，&lt;code&gt;c-&amp;gt;data&lt;/code&gt; 则是 &lt;code&gt;ngx_http_connection_t&lt;/code&gt; 的实例，&lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt;并没有区分这一情况，导致将实际按 &lt;code&gt;ngx_http_v2_connection_t&lt;/code&gt; 布局的数据按 &lt;code&gt;ngx_http_connection_t&lt;/code&gt;的结构来操作，从而引发了 segmentation fault。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void
ngx_http_v2_init(ngx_event_t *rev)
{
    ......
      
    c-&amp;gt;data = h2c; /* 赋值为 ngx_http_v2_connection_t 实例 */

    rev-&amp;gt;handler = ngx_http_v2_read_handler;
    c-&amp;gt;write-&amp;gt;handler = ngx_http_v2_write_handler;

    c-&amp;gt;idle = 1;

    ngx_http_v2_read_handler(rev);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int
ngx_http_lua_ssl_cert_handler(ngx_ssl_conn_t *ssl_conn, void *data)
{
    ......
    
    hc = c-&amp;gt;data; /* 此时应该是 h2c (ngx_http_v2_connection_t) = c-&amp;gt;data */
  
    ......
      
    r-&amp;gt;main_conf = hc-&amp;gt;conf_ctx-&amp;gt;main_conf; /* 可能导致 segmentation fault */
    r-&amp;gt;srv_conf = hc-&amp;gt;conf_ctx-&amp;gt;srv_conf;   /* 可能导致 segmentation fault */
    r-&amp;gt;loc_conf = hc-&amp;gt;conf_ctx-&amp;gt;loc_conf;   /* 可能导致 segmentation fault */
    
  ......
}
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因似乎找到了，我尝试通过 openssl s_client 这个工具来复现问题，但是没有成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo R | openssl s_client -connect ip:port -alpn h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（这里键入 &amp;ldquo;R&amp;rdquo; 是为了触发 SSL renegotation。）&lt;/p&gt;

&lt;p&gt;我想可能遗漏了一些重要细节，通过 gdb 单步跟踪，我发现在执行到 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 时，并没有执行到上述逻辑，而是走到了以下的逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int
ngx_http_lua_ssl_cert_handler(ngx_ssl_conn_t *ssl_conn, void *data)
{
    .......

    if (cctx &amp;amp;&amp;amp; cctx-&amp;gt;entered_cert_handler) {
        /* not the first time */

        if (cctx-&amp;gt;done) {
            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&amp;gt;log, 0,
                           &amp;quot;lua_certificate_by_lua: cert cb exit code: %d&amp;quot;,
                           cctx-&amp;gt;exit_code);

            dd(&amp;quot;lua ssl cert done, finally&amp;quot;);
            return cctx-&amp;gt;exit_code;
        }

        return -1;
    }
  
     .......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为早在第一次 SSL/TLS 握手时，&lt;code&gt;cctx-&amp;gt;entered_cert_handler&lt;/code&gt;就已经置为 1。所以第二次重新协商时，并没有处理我们期望的逻辑。&lt;/p&gt;

&lt;p&gt;反过来说，要出现这个问题，那么第一次 SSL/TLS 握手一定不能走到 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 的逻辑，这个函数实际设置在 OpenSSL 内部的 &lt;code&gt;s-&amp;gt;cert-&amp;gt;cert_cb&lt;/code&gt; 上，如果要该函数不被调用，说明第一次握手服务端没有发送证书链到客户端，即触发了SSL Session Reuse 机制。&lt;/p&gt;

&lt;p&gt;幸运的是，这仍然可以通过 openssl s_client 来验证猜测：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo R | openssl s_client -connect ip:port -reconnect -alpn h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后观察错误日志，发现进程果然崩溃，问题已经成功定位到！&lt;/p&gt;

&lt;p&gt;我已经将问题反馈到了 OpenResty 官方并提交了 &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/pull/1355&#34;&gt;PR&lt;/a&gt; 进行修复。值得注意的是，Nginx/1.15.2 已经彻底避免了这个问题，见 &lt;a href=&#34;http://hg.nginx.org/nginx/rev/dcab86115261&#34;&gt;dcab86115261&lt;/a&gt;；另外，如果 OpenSSL 版本低于 1.1.0，也不会有这个问题。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>