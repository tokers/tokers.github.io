<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>This is Alex Zhang</title>
    <link>https://tokers.github.io/</link>
    <description>Recent content on This is Alex Zhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 19 Aug 2018 16:43:18 +0800</lastBuildDate>
    
        <atom:link href="https://tokers.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>哈夫曼编码在 HTTP/2 协议中的应用</title>
      <link>https://tokers.github.io/posts/huffman_in_hpack/</link>
      <pubDate>Sun, 19 Aug 2018 16:43:18 +0800</pubDate>
      
      <guid>https://tokers.github.io/posts/huffman_in_hpack/</guid>
      <description>&lt;p&gt;今天笔者想要简单讨论下哈夫曼编码在 HTTP/2 协议中的相关应用。本文不对 HTTP/2 协议内容进行展开，如果不曾了解过 HTTP/2 协议的话，请自行查阅相关文档。&lt;/p&gt;

&lt;p&gt;HPACK 是 HTTP/2 协议里用于头部压缩的一种技术，它又包括索引和编码两部分，其中索引是将 HTTP 头部替换为索引下标，编码则是将头部名、头部值进行哈夫曼编码，从而达到压缩头部大小，节省网络带宽和对端解析时的 CPU 消耗。&lt;/p&gt;

&lt;p&gt;哈夫曼编码依赖于哈夫曼树。哈夫曼树利用了字符集中每个字符的不同权重，“贪心”得构造出的一颗 01 二叉树，其中权重小的字符所在节点离树的根节点更远（其编码相对较长），权重大的字符所在的节点里树更节点更近（其编码相对较短）。关于哈夫曼树，更多的请查阅&lt;a href=&#34;https://en.wikipedia.org/wiki/Huffman_coding&#34;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;HTTP/2 协议提供了 0-255 每个字符对应的哈夫曼编码（以及一个用于填充的字符，即 EOS，编码为 &lt;code&gt;0x3fffffff&lt;/code&gt;），这是通过分析大量 HTTP 头部的样本得到的。所有的 HTTP/2 协议实现都要按照这张表对 HTTP 头部进行编解码。&lt;/p&gt;

&lt;p&gt;如果了解了哈夫曼树的原理，那么再利用这张表构造出对应的哈夫曼树显得非常简单，解码时只需要在树上进行搜索即可，然而直接搜索的话，每次行进长度只有 1 个比特位，寻找一个编码长度为 N 的字符，时间复杂度是 O(N)。这并不是最优的方案，事实上，我们可以看到在 Nginx 和 nghttp2 的实现里，哈夫曼解码处理每次都是行进 4 个比特位，即寻找一个编码长度为 N 的字符，时间复杂度降到了 O(N / 4)，并且整棵哈夫曼树也被保存成一张表。&lt;/p&gt;

&lt;p&gt;每次行进 4 个比特位，实际上是将哈夫曼树扩展成为了一颗 16 叉树，因为每个节点都至多会有 16 个子节点。至于为什么是选择 4 个比特位而不是其他的，我想是因为考虑到编码时的便利性，因为刚好 4 个比特位是半个字节，我们可以通过简单的位运算得出 4 个比特位对应的值。然而此时问题也比之前更加复杂了一些，每次走 4 个比特位，我们需要记录下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据某一种走法走完 4 个比特位时，是否走到了非法的节点上（比如走到了 EOS 节点，或者途中某个节点不存在通往下个节点的路径）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;走完这 4 个比特位时，是否经过了某个编码的字符（在哈夫曼树上则对应到叶子节点）；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当所有头部的解码结束时，是否停留在一个“合法的节点”上，所谓合法的节点，指的是在这个节点上刚好完成一次解码操作，或者当前的路径（从根节点到当前节点），刚好是 EOS 的前缀；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不满足这些条件时，说明解码已经出错，对端没有按照协议标准对头部进行压缩。&lt;/p&gt;

&lt;p&gt;基于这些前提和条件，我用 Lua 语言写了一个生成哈夫曼解码表的&lt;a href=&#34;https://github.com/tokers/lua-resty-http2/blob/master/util/mkhuffdectbl&#34;&gt;程序&lt;/a&gt;，这为我实现 lua-resty-http2 奠定了基础，该部分参考了 Nginx 和 nghttp2。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ngx_lua 问题归档（1）</title>
      <link>https://tokers.github.io/posts/ngx-lua-drawback-record-1/</link>
      <pubDate>Sun, 05 Aug 2018 15:47:45 +0800</pubDate>
      
      <guid>https://tokers.github.io/posts/ngx-lua-drawback-record-1/</guid>
      <description>&lt;p&gt;前段时间在公司引流机器上偶然发现我们的 OpenResty/Nginx 服务存在进程崩溃的情况，错误日志里记录了如下的堆栈：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngx_http_lua_ssl_cert_handler
tls_post_process_client_hello+0x1be)
ossl_statem_server_post_process_message
read_state_machine
state_machine
ossl_statem_accept
ssl3_read_bytes
ssl3_read_internal
ssl3_read
ssl_read_internal
SSL_read
ngx_ssl_recv
ngx_http_v2_read_handler
ngx_http_v2_idle_handler
ngx_epoll_process_events
ngx_process_events_and_timers
ngx_worker_process_cycle
ngx_spawn_process
ngx_start_worker_processes
ngx_master_process_cycle
main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（在崩溃时打印其堆栈的功能是我们自己加入到 Nginx 中的，官方版本并不支持。）&lt;/p&gt;

&lt;p&gt;从堆栈信息来看，当前正在处理的连接，HTTP 协议已经升级到了  HTTP/2 （&lt;code&gt;ngx_http_v2_idle_handler&lt;/code&gt;）。而从偏顶部的函数来看，当前连接似乎又进入到了 SSL/TLS 握手协议的处理，既然堆栈上出现了 HTTP/2 相关的函数，说明当前一定不是第一次 SSL/TLS 握手（否则 HTTP 协议不可能为 HTTP/2），这让我联想到 &lt;a href=&#34;https://devcentral.f5.com/articles/ssl-profiles-part-6-ssl-renegotiation&#34;&gt;SSL renegotation&lt;/a&gt;，由于没有 coredump 文件的支持，从堆栈信息里看出来的仅限于这么多。&lt;/p&gt;

&lt;p&gt;问题至此，便只能带着问题去看源码了。既然问题还和 HTTP/2 有关，那么我猜测问题可能出现在某些地方没有兼容好 HTTP/2 相关逻辑有关，经过查看 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 函数（这是实现 &lt;code&gt;ssl_certificate_by_lua&lt;/code&gt; 功能的基础函数）和 HTTP/2 相关的逻辑，我发现问题出在 &lt;code&gt;c-&amp;gt;data&lt;/code&gt; 这个成员上，在协议升级到 HTTP/2 后，函数 &lt;code&gt;ngx_htp_v2_init&lt;/code&gt;会被调用到，这个函数将 &lt;code&gt;c-&amp;gt;data&lt;/code&gt; 赋值为了 &lt;code&gt;ngx_http_v2_connection_t&lt;/code&gt; 的一个实例，而在通常（非 HTTP/2） 的处理下，&lt;code&gt;c-&amp;gt;data&lt;/code&gt; 则是 &lt;code&gt;ngx_http_connection_t&lt;/code&gt; 的实例，&lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt;并没有区分这一情况，导致将实际按 &lt;code&gt;ngx_http_v2_connection_t&lt;/code&gt; 布局的数据按 &lt;code&gt;ngx_http_connection_t&lt;/code&gt;的结构来操作，从而引发了 segmentation fault。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void
ngx_http_v2_init(ngx_event_t *rev)
{
    ......
      
    c-&amp;gt;data = h2c; /* 赋值为 ngx_http_v2_connection_t 实例 */

    rev-&amp;gt;handler = ngx_http_v2_read_handler;
    c-&amp;gt;write-&amp;gt;handler = ngx_http_v2_write_handler;

    c-&amp;gt;idle = 1;

    ngx_http_v2_read_handler(rev);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int
ngx_http_lua_ssl_cert_handler(ngx_ssl_conn_t *ssl_conn, void *data)
{
    ......
    
    hc = c-&amp;gt;data; /* 此时应该是 h2c (ngx_http_v2_connection_t) = c-&amp;gt;data */
  
    ......
      
    r-&amp;gt;main_conf = hc-&amp;gt;conf_ctx-&amp;gt;main_conf; /* 可能导致 segmentation fault */
    r-&amp;gt;srv_conf = hc-&amp;gt;conf_ctx-&amp;gt;srv_conf;   /* 可能导致 segmentation fault */
    r-&amp;gt;loc_conf = hc-&amp;gt;conf_ctx-&amp;gt;loc_conf;   /* 可能导致 segmentation fault */
    
  ......
}
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原因似乎找到了，我尝试通过 openssl s_client 这个工具来复现问题，但是没有成功：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo R | openssl s_client -connect ip:port -alpn h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（这里键入 &amp;ldquo;R&amp;rdquo; 是为了触发 SSL renegotation。）&lt;/p&gt;

&lt;p&gt;我想可能遗漏了一些重要细节，通过 gdb 单步跟踪，我发现在执行到 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 时，并没有执行到上述逻辑，而是走到了以下的逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int
ngx_http_lua_ssl_cert_handler(ngx_ssl_conn_t *ssl_conn, void *data)
{
    .......

    if (cctx &amp;amp;&amp;amp; cctx-&amp;gt;entered_cert_handler) {
        /* not the first time */

        if (cctx-&amp;gt;done) {
            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&amp;gt;log, 0,
                           &amp;quot;lua_certificate_by_lua: cert cb exit code: %d&amp;quot;,
                           cctx-&amp;gt;exit_code);

            dd(&amp;quot;lua ssl cert done, finally&amp;quot;);
            return cctx-&amp;gt;exit_code;
        }

        return -1;
    }
  
     .......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为早在第一次 SSL/TLS 握手时，&lt;code&gt;cctx-&amp;gt;entered_cert_handler&lt;/code&gt;就已经置为 1。所以第二次重新协商时，并没有处理我们期望的逻辑。&lt;/p&gt;

&lt;p&gt;反过来说，要出现这个问题，那么第一次 SSL/TLS 握手一定不能走到 &lt;code&gt;ngx_http_lua_ssl_cert_handler&lt;/code&gt; 的逻辑，这个函数实际设置在 OpenSSL 内部的 &lt;code&gt;s-&amp;gt;cert-&amp;gt;cert_cb&lt;/code&gt; 上，如果要该函数不被调用，说明第一次握手服务端没有发送证书链到客户端，即触发了SSL Session Reuse 机制。&lt;/p&gt;

&lt;p&gt;幸运的是，这仍然可以通过 openssl s_client 来验证猜测：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo R | openssl s_client -connect ip:port -reconnect -alpn h2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后观察错误日志，发现进程果然崩溃，问题已经成功定位到！&lt;/p&gt;

&lt;p&gt;我已经将问题反馈到了 OpenResty 官方并提交了 &lt;a href=&#34;https://github.com/openresty/lua-nginx-module/pull/1355&#34;&gt;PR&lt;/a&gt; 进行修复。值得注意的是，Nginx/1.15.2 已经彻底避免了这个问题，见 &lt;a href=&#34;http://hg.nginx.org/nginx/rev/dcab86115261&#34;&gt;dcab86115261&lt;/a&gt;；另外，如果 OpenSSL 版本低于 1.1.0，也不会有这个问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://tokers.github.io/about/</link>
      <pubDate>Sat, 04 Aug 2018 15:52:20 +0800</pubDate>
      
      <guid>https://tokers.github.io/about/</guid>
      <description>

&lt;h1 id=&#34;hello-world&#34;&gt;Hello World&lt;/h1&gt;

&lt;p&gt;Hello, I am Chao Zhang (aka Alex Zhang), I&amp;rsquo;m a System Development Engineer at UPYUN Inc. My Email is &lt;a href=&#34;mailto:zchao1995@gmail.com&#34;&gt;zchao1995@gmail.com&lt;/a&gt; and the github ID is &lt;a href=&#34;https://github.com/tokers&#34;&gt;tokers&lt;/a&gt;. Why &amp;ldquo;tokers&amp;rdquo;? Because the name &amp;ldquo;Alex&amp;rdquo; in github is a &amp;ldquo;critical resource&amp;rdquo;, and &amp;ldquo;tokers&amp;rdquo; is the nickname that I created (random? maybe) since I was in college and played the &lt;a href=&#34;https://icpc.baylor.edu/&#34;&gt;ACM/ICPC&lt;/a&gt; competitions.&lt;/p&gt;

&lt;p&gt;Currently I&amp;rsquo;m concentrating with CDN (Content Delivery Network), involves so
many technologies, like &lt;a href=&#34;https://www.nginx.com/&#34;&gt;Nginx&lt;/a&gt;, &lt;a href=&#34;https://openresty.org/en/&#34;&gt;OpenResty&lt;/a&gt;, &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;, &lt;a href=&#34;https://golang.org/&#34;&gt;Golang&lt;/a&gt; and so forth.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m an OpenResty contributor. Moreover, I&amp;rsquo;m passionate with those techs.&lt;/p&gt;

&lt;p&gt;This site is used as my tech blog, interesting things will be archived.&lt;/p&gt;

&lt;h1 id=&#34;my-own-projects&#34;&gt;My Own Projects&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tokers/zstd-nginx-module&#34;&gt;zstd-nginx-module&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These Nginx C modules are used for taking the power of &lt;a href=&#34;https://facebook.github.io/zstd/&#34;&gt;ZStandard&lt;/a&gt; to Nginx.&lt;/p&gt;

&lt;p&gt;There are two modules here, one is &amp;ldquo;static&amp;rdquo;, for serving the existing .zstd
file on the disk. And the other one, is used to compress data with the sreaming
way.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tokers/lua-io-nginx-module&#34;&gt;lua-io-nginx-module&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This Nginx C module provides the basic file operations APIs with a mechanism that never block Nginx&amp;rsquo;s event loop. For now, it leverages Nginx&amp;rsquo;s thread pool, I/O operations might be offloaded to one of the free threads, and current Lua coroutine (Light Thread) will be yield until the I/O operations is done, in the meantime, Nginx in turn processes other events.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth to mention that the cost time of a single I/O operation won&amp;rsquo;t be reduced, it was just transferred from the main thread (the one executes the event loop) to another exclusive thread. Indeed, the overhead might be a little higher, because of the extra tasks transferring, lock waiting, Lua coroutine resumption (and can only be resumed in the next event loop) and so forth. Nevertheless, after the offloading, the main thread doesn&amp;rsquo;t block due to the I/O operation, and this is the fundamental advantage compared with the native Lua I/O library.&lt;/p&gt;

&lt;p&gt;The APIs are similar with the Lua I/O library, but with the totally different internal implementations, it doesn&amp;rsquo;t use the stream file facilities in libc (but keep trying to be consistent with it), the buffer is maintained inside this module, and follows Cosocket&amp;rsquo;s internals.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tokers/lua-resty-requests&#34;&gt;lua-resty-requests&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yet Another HTTP library for OpenResty! This HTTP library is for human beings, just like Python Request, APIs are trivil but wonderful.&lt;/p&gt;

&lt;p&gt;It provides many features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/1.0, HTTP/1.1 and HTTP/2 (WIP).&lt;/li&gt;
&lt;li&gt;SSL/TLS support.&lt;/li&gt;
&lt;li&gt;Chunked data support.&lt;/li&gt;
&lt;li&gt;Convenient interfaces to support features like json, authorization and etc.&lt;/li&gt;
&lt;li&gt;Stream interfaces to read request body.&lt;/li&gt;
&lt;li&gt;HTTP/HTTPS proxy.&lt;/li&gt;
&lt;li&gt;Latency metrics.&lt;/li&gt;
&lt;li&gt;Session support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m still working on this project and will improve it continuously.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tokers/lua-resty-http2&#34;&gt;lua-resty-http2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The HTTP/2 Protocol (Client Side) Implementation for OpenResty.&lt;/p&gt;

&lt;p&gt;This pure Lua library implements the client side HTTP/2 protocol, but not all the details are covered, for example, the stream dependencies is maintained but never used.&lt;/p&gt;

&lt;p&gt;There are some inherent limitations which are not solved, however. For more
details, you can just read the README.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hmmm, I will replenish this list in the future. :)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>